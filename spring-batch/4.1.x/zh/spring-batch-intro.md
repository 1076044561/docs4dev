## 1. Spring 季批次介绍

企业域中的许多应用程序需要批量处理才能在关键任务环境中执行业务操作 . 这些业务运营包括：


- 
无需用户交互即可最有效地处理大量信息的自动化，复杂处理 . 这些操作通常包括基于时间的事件（例如月末计算，通知或通信） . 


- 
在非常大的数据集中重复处理复杂业务规则的定期应用（例如，保险利益确定或费率调整） . 


- 
集成从内部和外部系统接收的信息，这些信息通常需要以事务方式格式化，验证和处理到记录系统中 . 批处理用于每天为企业处理数十亿的交易 . 

Spring Batch是一个轻量级，全面的批处理框架，旨在开发对企业系统日常运营至关重要的强大批处理应用程序 .  Spring Batch构建了人们期望的Spring Framework特性（ 生产环境 力，基于POJO的开发方法和一般易用性），同时使开发人员可以在必要时轻松访问和利用更高级的企业服务 .  Spring Batch不是一个调度框架 . 在商业和开源空间中都有许多好的企业调度程序（例如Quartz，Tivoli，Control-M等） . 它旨在与调度程序一起使用，而不是替换调度程序 . 

Spring Batch提供了可重复使用的功能，这些功能对于处理大量记录至关重要，包括记录/跟踪，事务管理，作业处理统计，作业重启，跳过和资源管理 . 它还提供更高级的技术服务和功能，通过优化和分区技术实现极高容量和高性能的批处理作业 .  Spring Batch可用于两种简单的用例（例如将文件读入数据库或运行存储过程）以及复杂的大量用例（例如在数据库之间移动大量数据，转换它等等）上） . 大批量批处理作业可以高度可扩展的方式利用该框架来处理大量信息 . 


### 1.1.背景

虽然开源软件项目和相关社区更加关注基于Web和基于微服务的体系结构框架，但显然缺乏对可重用体系结构框架的关注以适应基于Java的批处理需求，尽管需要继续处理这种需求 . 在企业IT环境中处理 . 缺乏标准的，可重复使用的批处理体系结构导致在客户企业IT功能中开发的许多一次性内部解决方案的激增 . 

SpringSource（现为Pivotal）和埃森哲合作改变了这一点 . 埃森哲在实施批量架构方面的实践行业和技术经验，SpringSource深厚的技术经验以及Spring经过验证的编程模型共同构成了一个自然而强大的合作伙伴关系，以创建高质量，市场相关的软件，旨在填补企业Java中的重要空白 . 两家公司都与许多通过开发基于Spring的批处理架构解决方案解决类似问题的客户合作 . 这提供了一些有用的额外细节和实际约束，有助于确保解决方案可以应用于客户提出的现实问题 . 

埃森哲为Spring Batch项目贡献了以前专有的批处理体系结构框架，以及提供支持，增强功能和现有功能集的提交者资源 . 埃森哲的贡献是基于在过去几代平台上构建批量架构的数十年经验：COBOL / Mainframe，C / Unix以及现在的Java / Anywhere . 

埃森哲与SpringSource之间的合作旨在促进软件处理方法，框架和工具的标准化，在创建批处理应用程序时，企业用户可以始终如一地利用这些方法，框架和工具 . 希望为其企业IT环境提供标准的，经过验证的解决方案的公司和政府机构可以从Spring Batch中受益 . 


### 1.2.使用场景

典型的批处理程序一般：


- 
从数据库，文件或队列中读取大量记录 . 


- 
以某种方式处理数据 . 


- 
以修改的形式写回数据 . 

Spring Batch自动执行此基本批处理迭代，提供处理类似事务的功能，通常在脱机环境中处理，无需任何用户交互 . 批处理作业是大多数IT项目的一部分，Spring Batch是唯一的开源框架这提供了一个强大的企业级解决方案 . 

业务场景


- 
定期提交批处理


- 
并发批处理：并行处理作业


- 
分阶段的企业消息驱动处理


- 
大规模并行批处理


- 
失败后手动或预定重启


- 
依赖步骤的顺序处理（使用扩展的toworkflow驱动批次）


- 
部分处理：跳过记录（例如，回滚时）


- 
整批交易，适用于批量较小或现有存储过程/脚本的情况

技术目标


- 
批处理开发人员使用Spring编程模型：专注于业务逻辑，让框架负责基础架构 . 


- 
清楚地分离基础架构，批处理执行环境和批处理应用程序之间的关注点 . 


- 
提供通用的核心执行服务作为所有项目可以实现的接口 . 


- 
提供可以“开箱即用”使用的核心执行接口的简单和默认实现 . 


- 
通过在所有层中利用spring框架，易于配置，定制和扩展服务 . 


- 
所有现有的核心服务都应易于更换或扩展，而不会对基础架构层产生任何影响 . 


- 
提供一个简单的部署模型，使用Maven构建的JAR与应用程序完全分离 . 


### 1.3. Spring Batch Architecture

Spring Batch的设计具有可扩展性和多样化的最终用户群 . 下图显示了支持最终用户开发人员的可扩展性和易用性的分层体系结构 . 


![Figure 1.1: Spring Batch Layered Architecture](https://www.docs4dev.com/images/9f01e9db-cd3c-45b6-99fb-0933e9a5d8bd.png)


图1. Spring Batch分层架构

这种分层架构突出了三个主要的高级组件：应用程序，核心和基础架构 . 该应用程序包含开发人员使用Spring Batch编写的所有批处理作业和自定义代码 .  Batch Core包含启动和控制批处理作业所需的核心运行时类 . 它包括 `JobLauncher` ， `Job` 和 `Step` 的实现 .  Application和Core都 Build 在通用基础架构之上 . 此基础结构包含常见的读取器和编写器和服务（例如 `RetryTemplate` ），它们由应用程序开发人员（读者和编写者，如 `ItemReader` 和 `ItemWriter` ）和核心框架本身（重试，它是自己的库）使用 . 


### 1.4.一般批次原则和指南

在构建批处理解决方案时，应考虑以下关键原则，指南和一般注意事项 . 


- 
请记住，批处理体系结构通常会影响在线体系结构，反之亦然 . 尽可能使用通用构建块来考虑架构和环境 . 


- 
尽可能简化并避免在单批应用程序中构建复杂的逻辑结构 . 


- 
保持数据的处理和存储在物理上靠得很近（换句话说，将数据保存在处理过程中） . 


- 
最大限度地减少系统资源的使用，尤其是I / O.在内部存储器中执行尽可能多的操作 . 


- 
查看应用程序I / O（分析SQL语句）以确保避免不必要的物理I / O.特别是，需要寻找以下四个常见缺陷：


- 
当数据可以被读取一次并缓存或保存在工作存储中时，读取每个事务的数据 . 


- 
重新读取先前在同一事务中读取数据的事务的数据 . 


- 
导致不必要的表或索引扫描 . 


- 
未在SQL语句的WHERE子句中指定键值 . 


- 
在批处理运行中不要做两次事情 . 例如，如果您需要数据汇总以用于报告目的，则应该（如果可能）在最初处理数据时递增存储的总计，因此您的报告应用程序不必重新处理相同的数据 . 


- 
在批处理应用程序开始时分配足够的内存，以避免在此过程中进行耗时的重新分配 . 


- 
总是假设数据完整性最差 . 插入足够的检查和记录验证以维护数据完整性 . 


- 
尽可能实施校验和以进行内部验证 . 例如，平面文件应该有一个预告片记录，告诉文件中的记录总数以及关键字段的汇总 . 


- 
在具有真实数据量的类似 生产环境 环境中尽早计划和执行压力测试 . 


- 
在大批量系统中，备份可能具有挑战性，特别是如果系统以24-7为基础同时在线运行 . 数据库备份通常在在线设计中得到很好的处理，但文件备份应该被视为同样重要 . 如果系统依赖于平面文件，则文件备份程序不仅应该到位并记录在案，而应定期进行测试好 . 


### 1.5.批处理策略

为了帮助设计和实现批处理系统，应该以样本结构图和代码shell的形式向设计人员和程序员提供基本的批处理应用程序构建块和模式 . 在开始设计批处理作业时，应将业务逻辑分解为一系列步骤，这些步骤可使用以下标准构建块实现：


- 
转换应用程序：对于由外部系统提供或生成的每种类型的文件，必须创建转换应用程序以将提供的事务记录转换为处理所需的标准格式 . 此类批处理应用程序可以部分或全部由转换实用程序模块组成（请参阅基本批处理服务） . 


- 
验证应用程序：验证应用程序确保所有输入/输出记录正确且一致 . 验证通常基于文件头和预告片，校验和和验证算法以及记录级交叉检查 . 


- 
提取应用程序：从数据库或输入文件中读取一组记录，根据预定义规则选择记录，并将记录写入输出文件的应用程序 . 


- 
提取/更新应用程序：从数据库或输入文件中读取记录并对由每个输入记录中的数据驱动的数据库或输出文件进行更改的应用程序 . 


- 
处理和更新应用程序：对提取或验证应用程序的输入事务执行处理的应用程序 . 处理通常涉及读取数据库以获取处理所需的数据，可能更新数据库并创建输出处理的记录 . 


- 
输出/格式应用程序：读取输入文件的应用程序，根据标准格式从该记录重组数据，并生成用于打印或传输到另一个程序或系统的输出文件 . 

此外，应为无法使用前面提到的构建块构建的业务逻辑提供基本应用程序shell . 

除了主要构建块之外，每个应用程序还可以使用一个或多个标准实用程序步骤，例如：


- 
排序：读取输入文件并生成输出文件的程序，其中记录已根据记录中的排序键字段重新排序 . 排序通常由标准系统实用程序执行 . 


- 
拆分：一个程序，它读取单个输入文件，并根据字段值将每个记录写入多个输出文件之一 . 可以通过参数驱动的标准系统实用程序来定制或执行拆分 . 


- 
合并：一种程序，它从多个输入文件中读取记录，并生成一个输出文件，其中包含来自输入文件的组合数据 . 可以通过参数驱动的标准系统实用程序来定制或执行合并 . 

批量应用程序还可以通过其输入源进行分类：


- 
数据库驱动的应用程序由从数据库检索的行或值驱动 . 


- 
文件驱动的应用程序由从文件中检索的记录或值驱动 . 


- 
消息驱动的应用程序由从消息队列中检索的消息驱动 . 

任何批处理系统的基础都是处理策略 . 影响策略选择的因素包括：估计的批处理系统容量，与在线系统或其他批处理系统的并发性，可用的批处理窗口 .  （请注意，随着越来越多的企业想要全天候运行，明确的批处理窗口正在消失） . 

批处理的典型处理选项是（按实现复杂度的递增顺序）：


- 
在离线模式下批处理窗口期间的正常处理 . 


- 
并发批处理或在线处理 . 


- 
并行处理许多不同的批次运行或作业 . 


- 
分区（同时处理同一作业的许多实例） . 


- 
上述选项的组合 . 

商业调度程序可以支持部分或全部这些选项 . 

以下部分更详细地讨论了这些处理选项 . 重要的是要注意，根据经验，批处理采用的提交和锁定策略取决于执行的处理类型，并且在线锁定策略也应该使用相同的原则 . 因此，在设计整体架构时，批处理架构不能简单地成为事后的想法 . 

锁定策略可以是仅使用普通数据库锁或在体系结构中实现其他自定义锁定服务 . 锁定服务将跟踪数据库锁定（例如，通过将必要信息存储在专用db表中）并对请求db操作的应用程序提供或拒绝权限 . 此架构还可以实现重试逻辑，以避免在发生锁定情况时中止批处理作业 . 

 **1. Normal processing in a batch window** 简单批处理进程在单独的批处理窗口中运行，其中在线用户或其他批处理过程不需要更新数据，并发不是问题，可以在批处理运行结束时完成单个提交 . 

在大多数情况下，更健壮的方法更合适 . 请记住，批处理系统随着时间的推移有增长的趋势，无论是在复杂性还是处理的数据量方面 . 如果没有锁定策略并且系统仍然依赖于单个提交点，则修改批处理程序可能会很痛苦 . 因此，即使使用最简单的批处理系统，也需要考虑重启恢复选项的提交逻辑以及本节后面描述的更复杂情况的信息 . 

 **2. Concurrent batch or on-line processing** 处理可由在线用户同时更新的数据的批处理应用程序不应锁定在线用户可能需要的任何数据（数据库或文件中）超过几秒钟 . 此外，应在每次交易结束时将更新提交到数据库 . 这最小化了其他进程不可用的数据部分以及数据不可用的时间 . 

最小化物理锁定的另一个选项是使用乐观锁定模式或悲观锁定模式实现逻辑行级锁定 . 


- 
乐观锁定假设记录争用的可能性很小 . 它通常意味着在批处理和联机处理同时使用的每个数据库表中插入时间戳列 . 当应用程序提取行进行处理时，它还会获取时间戳 . 当应用程序尝试更新已处理的行时，更新将使用WHERE子句中的原始时间戳 . 如果时间戳匹配，则更新数据和时间戳 . 如果时间戳不匹配，则表示另一个应用程序在获取和更新尝试之间更新了同一行 . 因此，无法执行更新 . 


- 
悲观锁定是任何锁定策略，假设存在记录争用的高可能性，因此需要在检索时获得物理或逻辑锁定 . 一种悲观逻辑锁定使用数据库表中的专用锁定列 . 当应用程序检索更新行时，它会在锁定列中设置一个标志 . 在标志到位的情况下，尝试检索同一行的其他应用程序在逻辑上失败 . 当设置标志的应用程序更新该行时，它还会清除该标志，从而使该行能够被其他应用程序检索 . 请注意，必须在初始提取和标志设置之间维护数据的完整性，例如使用数据库锁（例如 `SELECT FOR UPDATE` ） . 另请注意，此方法的缺点与物理锁定相同，除了管理构建超时机制更容易，如果用户在锁定记录时进入午餐，则会释放锁定 . 

这些模式不一定适合批处理，但它们可能用于并发批处理和联机处理（例如在数据库不支持行级锁定的情况下） . 作为一般规则，乐观锁定更适合在线应用程序，而悲观锁定更适合批处理应用程序 . 每当使用逻辑锁定时，必须对访问受逻辑锁保护的数据实体的所有应用程序使用相同的方案 . 

请注意，这两种解决方案仅解决锁定单个记录的问题 . 通常，我们可能需要锁定逻辑上相关的记录组 . 使用物理锁，您必须非常小心地管理这些，以避免潜在的死锁 . 使用逻辑锁，通常最好构建一个逻辑锁管理器，它理解您要保护的逻辑记录组，并确保锁是连贯的和非死锁的 . 此逻辑锁管理器通常使用自己的表进行锁管理，争用报告，超时机制和其他问题 . 

 **3. Parallel Processing** 并行处理允许多个批处理运行或作业并行运行，以最大限度地减少总批处理时间 . 只要作业不共享相同的文件，db-tables或索引空间，这就不是问题 . 如果他们这样做，则应使用分区数据实现此服务 . 另一种选择是通过使用控制表来构建用于维护相互依赖性的体系结构模块 . 控制表应包含每个共享资源的行以及它是否正由应用程序使用 . 然后，批处理体系结构或并行作业中的应用程序将从该表中检索信息，以确定它是否可以访问它所需的资源 . 

如果数据访问不是问题，则可以通过使用额外的线程并行处理来实现并行处理 . 在大型机环境中，并行作业类传统上一直使用，以确保所有进程有足够的CPU时间 . 无论如何，该解决方案必须足够强大，以确保所有正在运行的进程的时间片 . 

并行处理中的其他关键问题包括负载 balancer 和一般系统资源（如文件，数据库缓冲池等）的可用性 . 另请注意，控制表本身很容易成为关键资源 . 

 **4. Partitioning** 使用分区允许多个版本的大批量应用程序同时运行 . 这样做的目的是减少处理长批处理作业所需的时间 . 可以成功分区的进程是可以拆分输入文件和/或对主数据库表进行分区以允许应用程序针对不同数据集运行的进程 . 

此外，必须将分区的进程设计为仅处理其分配的数据集 . 分区架构必须与数据库设计和数据库分区策略紧密相关 . 请注意，数据库分区并不一定意味着数据库的物理分区，尽管在大多数情况下这是可取的 . 下图说明了分区方法：


![Figure 1.2: Partitioned Process](https://www.docs4dev.com/images/53e6eeda-ac35-4072-b526-b55275be4efb.png)


图2.分区过程

该体系结构应足够灵活，以允许动态配置分区数 . 应考虑自动和用户控制的配置 . 自动配置可以基于诸如输入文件大小和输入记录的数量之类的参数 . 

 **4.1 Partitioning Approaches** 选择分区方法必须根据具体情况进行 . 以下列表描述了一些可能的分区方法：

1.记录集的固定和均匀分解

这涉及将输入记录集分成偶数个部分（例如，10，其中每个部分恰好是整个记录集的十分之一） . 然后，每个部分由批/提取应用程序的一个实例处理 . 

为了使用这种方法，需要预处理来分割记录集 . 此拆分的结果将是下限和上限放置编号，可用作批处理/提取应用程序的输入，以便将其处理限制为仅其部分 . 

预处理可能是一个很大的开销，因为它必须计算和确定记录集的每个部分的边界 . 

2.按键列分解

这涉及拆分由键列（例如位置代码）设置的输入记录，并将每个键的数据分配给批处理实例 . 为了实现这一点，列值可以是：


- 
通过分区表分配给批处理实例（本节稍后介绍） . 


- 
通过值的一部分（例如0000-0999,1000-1999等）分配给批处理实例 . 

在选项1下，添加新值意味着手动重新配置批处理/提取以确保将新值添加到特定实例 . 

在选项2下，这可确保通过批处理作业的实例覆盖所有值 . 但是，一个实例处理的值的数量取决于列值的分布（0000-0999范围内可能有大量位置，1000-1999范围内可能很少） . 在此选项下，数据范围应设计为考虑分区 . 

在这两个选项下，无法实现记录到批处理实例的最佳均匀分布 . 没有动态配置使用的批处理实例数 . 

3.按意见分解

这种方法基本上是由关键列分解但在数据库级别 . 它涉及将记录集分解为视图 . 批处理应用程序的每个实例在处理过程中都使用这些视图 . 分解是通过对数据进行分组来完成的 . 

使用此选项，必须将批处理应用程序的每个实例配置为命中特定视图（而不是主表） . 此外，通过添加新数据值，必须将这组新数据包含在视图中 . 没有动态配置功能，因为实例数量的更改会导致视图发生更改 . 

4.增加处理指标

这涉及向输入表添加新列，该列充当指示符 . 作为预处理步骤，所有指标都标记为未处理 . 在批处理应用程序的记录获取阶段，读取记录的条件是该记录被标记为未处理，并且一旦读取它们（带锁定），它们就被标记为正在处理中 . 完成该记录后，指标将更新为完成或错误 . 可以在不进行更改的情况下启动批处理应用程序的许多实例，因为附加列确保仅处理一次记录 . 在“完成时，指标被标记为完成”的顺序中的一两句话 . ）

使用此选项，表上的I / O会动态增加 . 在一个案例中更新批处理应用程序时，这种影响会减少，因为无论如何都必须进行写入 . 

5.将表提取到平面文件

这涉及将表提取到文件中 . 然后，可以将此文件拆分为多个段，并将其用作批处理实例的输入 . 

使用此选项，将表提取到文件并拆分它的额外开销可能会抵消多分区的影响 . 可以通过更改文件拆分脚本来实现动态配置 . 

6.使用哈希柱

此方案涉及向用于检索驱动程序记录的数据库表添加哈希列（键/索引） . 此哈希列具有一个指示器，用于确定批处理应用程序的哪个实例处理此特定行 . 例如，如果要启动三个批处理实例，则指示符“A”标记用于由实例1处理的行，指示符“B”标记用于由实例2处理的行，以及指示符“C” '标记了实例3处理的行 . 

然后，用于检索记录的过程将有一个额外的 `WHERE` 子句来选择由特定指示符标记的所有行 . 此表中的插入将涉及添加标记字段，该字段将默认为其中一个实例（例如“A”） . 

将使用简单的批处理应用程序来更新指示符，例如在不同实例之间重新分配负载 . 当添加了足够多的新行时，可以运行此批处理（除批处理窗口外的任何时间）以将新行重新分发到其他实例 . 

批处理应用程序的其他实例仅需要运行前面段落中描述的批处理应用程序，以重新分配指示符以使用新的实例数 . 

 **4.2 Database and Application Design Principles** 

支持使用键列方法针对分区数据库表运行的多分区应用程序的体系结构应包括用于存储分区参数的中央分区存储库 . 这提供了灵活性并确保了可维护性 . 存储库通常由单个表组成，称为分区表 . 

存储在分区表中的信息是静态的，通常应由DBA维护 . 该表应包含多行分区应用程序的每个分区的一行信息 . 该表应包含Program ID Code，Partition Number（分区的逻辑ID），此分区的db key列的Low Value以及此分区的db key列的High Value . 

在程序启动时，程序 `id` 和分区号应该从架构（特别是从Control Processing Tasklet）传递给应用程序 . 如果使用键列方法，则使用这些变量来读取分区表，以确定应用程序要处理的数据范围 . 此外，在整个处理过程中必须使用分区号：


- 
添加到输出文件/数据库更新，以使合并过程正常工作 . 


- 
向批处理日志报告正常处理，并向架构错误处理程序报告任何错误 . 

 **4.3 Minimizing Deadlocks** 

当应用程序并行运行或进行分区时，可能会发生数据库资源争用和死锁 . 作为数据库设计的一部分，数据库设计团队尽可能消除潜在的争用情况至关重要 . 

此外，开发人员必须确保数据库索引表的设计时考虑到死锁和性能 . 

管理或体系结构表中经常出现死锁或热点，例如日志表，控制表和锁定表 . 还应考虑到这些问题的影响 . 实际压力测试对于识别架构中可能存在的瓶颈至关重要 . 

为了最大限度地减少冲突对数据的影响，架构应在附加到数据库或遇到死锁时提供等待和重试间隔等服务 . 这意味着内置机制对某些数据库返回代码作出反应，而不是发出立即错误，等待预定的时间并重试数据库操作 . 

 **4.4 Parameter Passing and Validation** 

分区架构应该对应用程序开发人员相对透明 . 该体系结构应执行与以分区模式运行应用程序相关的所有任务，包括：


- 
在应用程序启动之前检索分区参数 . 


- 
在应用程序启动之前验证分区参数 . 


- 
在启动时将参数传递给应用程序 . 

验证应包括检查以确保：


- 
应用程序有足够的分区来覆盖整个数据范围 . 


- 
分区之间没有间隙 . 

如果数据库已分区，则可能需要进行一些额外的验证，以确保单个分区不跨越数据库分区 . 

此外，该体系结构应考虑分区的合并 . 关键问题包括：


- 
在进入下一个工作步骤之前，是否必须完成所有分区？


- 
如果其中一个分区中止会发生什么？